package main

//861. 翻转矩阵后的得分
//有一个二维矩阵 A 其中每个元素的值为 0 或 1 。
//
//移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
//
//在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
//
//返回尽可能高的分数。
//
// 
//
//示例：
//
//输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
//输出：39
//解释：
//转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
//0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
// 
//
//提示：
//
//1 <= A.length <= 20
//1 <= A[0].length <= 20
//A[i][j] 是 0 或 1

//贪婪算法
// 第一列满足最大，先行变换，后列变换
// 每列满足1的数量最多的方向变换
// 可以根据每列的贡献进行累加计算

func matrixScore(A [][]int) int {
	m, n := len(A), len(A[0])
	result := 1 << (n - 1) * m
	for col := 1; col < n; col++ {
		count := 0
		for row := 0;row < m;row++{
			if A[row][0] == A[row][col]{
				count ++
			}
		}
		if count < m - count{
			count = m - count
		}
		result += 1<<(n-col-1) * count
	}
	return result
}
